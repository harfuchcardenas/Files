#!/usr/bin/perl

use strict; # Enforce stricter parsing and error checking
use warnings; # Enable warnings for potential problems
use Cwd 'abs_path'; # Import abs_path function from Cwd module for absolute path
use File::Spec; # Import File::Spec for path manipulation (e.g., building full paths)
use File::Basename; # Import basename function for extracting file/directory names

# ANSI escape codes for text colors and styles
use constant {
    COLOR_BLUE          => "\e[34m",   # Marino (original, not used for files/links in this version)
    COLOR_GREEN         => "\e[32m",   # Verde
    COLOR_CYAN          => "\e[36m",   # CIANO - New color for regular files
    COLOR_BOLD          => "\e[1m",
    COLOR_RESET         => "\e[0m",
};

# Determine the target directory path.
# If an argument is provided, use it; otherwise, default to the current directory ('.').
my $directory_input;
my $count_only = 0; # Flag for the new -n feature

if (@ARGV) {
    if ($ARGV[0] eq '-n') {
        $count_only = 1;
        $directory_input = '.'; # When -n is used, always count in the current directory
    } else {
        $directory_input = $ARGV[0];
    }
} else {
    $directory_input = '.';
}

# Resolve the absolute path to handle relative paths like '.' or '..'.
# This makes the path unambiguous and ensures operations work reliably.
my $abs_directory_path = eval { abs_path($directory_input) };

# Validate that the resolved path exists and is indeed a directory.
# If not, print an appropriate error message and exit.
unless (defined $abs_directory_path && -d $abs_directory_path) {
    if (defined $abs_directory_path) {
        # Path exists but is not a directory (e.g., it's a file)
        print "Error: '$abs_directory_path' contains no directories.\n";
    } else {
        # Path could not be resolved or does not exist (e.g., misspelled, non-existent)
        print "Error: '$directory_input' does not exist.\n";
    }
    exit 1; # Exit with a non-zero status to indicate an error
}

# --- Core Logic to List Files and Links or Count Files ---

my @found_files_and_links;  # Array to store full paths of files and links found
my $has_subdirectories = 0;   # Flag to check if any subdirectories exist
my $file_count = 0; # Counter for the -n option

# Open the target directory for reading.
opendir(my $dh, $abs_directory_path) or die "The directory '$abs_directory_path' cannot be opened: $!";

# Read each entry in the directory.
while (my $entry = readdir $dh) {
    # Skip '.' (current directory) and '..' (parent directory) entries.
    next if ($entry eq '.' || $entry eq '..');

    # Construct the full path to the entry.
    my $full_entry_path = File::Spec->catfile($abs_directory_path, $entry);

    # Check if the entry is a file, a link, or a directory.
    if (-f $full_entry_path || -l $full_entry_path) { # -f for files, -l for symbolic links
        $file_count++; # Increment count for both files and links
        unless ($count_only) { # Only store if not in count-only mode
            push @found_files_and_links, {
                path => $full_entry_path,
                type => (-l $full_entry_path ? 'link' : 'file') # Determine type
            };
        }
    } elsif (-d $full_entry_path) {
        $has_subdirectories = 1; # Set flag if a directory is found
    }
}

# Close the directory handle.
closedir $dh;

# --- Conditional Output based on what was found or the -n option ---

if ($count_only) {
    print "Number of files in the current directory: $file_count\n";
} elsif (@found_files_and_links) {
    # Sort files and links by modified date in ascending order (oldest first).
    # (stat($a->{path}))[9] gets the modification time (mtime) for the path in the hash reference.
    foreach my $item (sort { (stat($a->{path}))[9] <=> (stat($b->{path}))[9] } @found_files_and_links) {
        # Extract just the file/link name from the full path using basename()
        my $item_name = basename($item->{path});
        my $color_code;
        my $bold_code = ''; # Start with no bold, add if needed

        if ($item->{type} eq 'link') {
            $color_code = COLOR_GREEN;
            $bold_code = COLOR_BOLD; # Links should be bold green
        } else { # Must be a regular file
            $color_code = COLOR_CYAN;
            # Files are just cyan, not bold
        }

        # Print the item name with the appropriate color and bold (if applicable)
        print $bold_code . $color_code . "'$item_name'" . COLOR_RESET . "\n";
    }
} elsif ($has_subdirectories) {
    # If no files or links were found but there are directories
    print "Only directories can be found in the specified path.\n";
} else {
    # If neither files, links, nor directories were found (directory is empty)
    print "There are neither files nor links in the specified path.\n";
}

exit 0; # Exit successfully
