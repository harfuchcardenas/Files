#!/usr/bin/perl

use strict; # Enforce stricter parsing and error checking
use warnings; # Enable warnings for potential problems
use Cwd 'abs_path'; # Import abs_path function from Cwd module for absolute path
use File::Spec; # Import File::Spec for path manipulation (e.g., building full paths)
use File::Basename; # Import basename function for extracting file/directory names

# ANSI escape codes for text colors and styles
# \e[34m sets foreground color to blue
# \e[1m sets text to bold
# \e[0m resets all attributes (color, bold, etc.) to default
use constant {
    COLOR_BLUE  => "\e[34m",
    COLOR_BOLD  => "\e[1m",
    COLOR_RESET => "\e[0m",
};

# Determine the target directory path.
# If an argument is provided, use it; otherwise, default to the current directory ('.').
my $directory_input;
if (@ARGV) {
    $directory_input = $ARGV[0];
} else {
    $directory_input = '.';
}

# Resolve the absolute path to handle relative paths like '.' or '..'.
# This makes the path unambiguous and ensures operations work reliably.
my $abs_directory_path = eval { abs_path($directory_input) };

# Validate that the resolved path exists and is indeed a directory.
# If not, print an appropriate error message and exit.
unless (defined $abs_directory_path && -d $abs_directory_path) {
    if (defined $abs_directory_path) {
        # Path exists but is not a directory (e.g., it's a file)
        print "Error: The path '$abs_directory_path' exists but is not a directory.\n";
    } else {
        # Path could not be resolved or does not exist (e.g., misspelled, non-existent)
        print "Error: The specified path '$directory_input' is invalid or does not exist.\n";
    }
    exit 1; # Exit with a non-zero status to indicate an error
}

# --- Core Logic to List Files Only ---

my @found_files;       # Array to store full paths of files found
my $has_subdirectories = 0; # Flag to check if any subdirectories exist

# Open the target directory for reading.
opendir(my $dh, $abs_directory_path) or die "Cannot open directory '$abs_directory_path': $!";

# Read each entry in the directory.
while (my $entry = readdir $dh) {
    # Skip '.' (current directory) and '..' (parent directory) entries.
    next if ($entry eq '.' || $entry eq '..');

    # Construct the full path to the entry.
    my $full_entry_path = File::Spec->catfile($abs_directory_path, $entry);

    # Check if the entry is a file or a directory.
    if (-f $full_entry_path) {
        push @found_files, $full_entry_path; # Store the full path for sorting by date
    } elsif (-d $full_entry_path) {
        $has_subdirectories = 1; # Set flag if a directory is found
    }
}

# Close the directory handle.
closedir $dh;

# --- Conditional Output based on what was found ---

if (@found_files) {
    # Sort files by modified date in ascending order (oldest first).
    # (stat($a))[9] gets the modification time (mtime) in seconds since epoch for file $a.
    # <=> is the numeric comparison operator.
    # $a <=> $b sorts in ascending order (oldest first).
    foreach my $file_path (sort { (stat($a))[9] <=> (stat($b))[9] } @found_files) {
        # Extract just the file name from the full path using basename()
        my $file_name = basename($file_path);
        # Print only the file name, in blue and bold
        print COLOR_BOLD . COLOR_BLUE . "'$file_name'" . COLOR_RESET . "\n";
    }
} elsif ($has_subdirectories) {
    # If no files were found but there are directories
    print "Only directories found in the specified directory.\n";
} else {
    # If neither files nor directories were found (directory is empty)
    print "No files found in the specified directory.\n";
}

exit 0; # Exit successfully

